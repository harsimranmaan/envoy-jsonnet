// Message type: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext';
local generator = import '../generator.libsonnet';
local fields = {
  allow_expired_certificate: {
    type: 'bool',
    allowedNames: [
      'allow_expired_certificate',
      'allowExpiredCertificate',
    ],
  },
  ca_certificate_provider_instance: {
    type: 'envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance',
    allowedNames: [
      'ca_certificate_provider_instance',
      'caCertificateProviderInstance',
    ],
  },
  crl: {
    type: 'envoy.config.core.v3.DataSource',
    allowedNames: [
      'crl',
    ],
  },
  custom_validator_config: {
    type: 'envoy.config.core.v3.TypedExtensionConfig',
    allowedNames: [
      'custom_validator_config',
      'customValidatorConfig',
    ],
  },
  match_subject_alt_names: {
    type: 'envoy.type.matcher.v3.StringMatcher',
    allowedNames: [
      'match_subject_alt_names',
      'matchSubjectAltNames',
    ],
    containerType: 'list',
  },
  match_typed_subject_alt_names: {
    type: 'envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher',
    allowedNames: [
      'match_typed_subject_alt_names',
      'matchTypedSubjectAltNames',
    ],
    containerType: 'list',
  },
  max_verify_depth: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'max_verify_depth',
      'maxVerifyDepth',
    ],
    constraints: {
      Uint32: {
        lte: 100,
      },
    },
  },
  only_verify_leaf_cert_crl: {
    type: 'bool',
    allowedNames: [
      'only_verify_leaf_cert_crl',
      'onlyVerifyLeafCertCrl',
    ],
  },
  require_signed_certificate_timestamp: {
    type: 'google.protobuf.BoolValue',
    allowedNames: [
      'require_signed_certificate_timestamp',
      'requireSignedCertificateTimestamp',
    ],
  },
  trust_chain_verification: {
    type: 'envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification',
    allowedNames: [
      'trust_chain_verification',
      'trustChainVerification',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  trusted_ca: {
    type: 'envoy.config.core.v3.DataSource',
    allowedNames: [
      'trusted_ca',
      'trustedCa',
    ],
  },
  verify_certificate_hash: {
    type: 'string',
    allowedNames: [
      'verify_certificate_hash',
      'verifyCertificateHash',
    ],
    containerType: 'list',
    constraints: {
      Repeated: {
        items: {
          Type: {
            String_: {
              WellKnown: null,
              max_bytes: 95,
              min_len: 64,
            },
          },
        },
      },
    },
  },
  verify_certificate_spki: {
    type: 'string',
    allowedNames: [
      'verify_certificate_spki',
      'verifyCertificateSpki',
    ],
    containerType: 'list',
    constraints: {
      Repeated: {
        items: {
          Type: {
            String_: {
              WellKnown: null,
              max_bytes: 44,
              min_len: 44,
            },
          },
        },
      },
    },
  },
  watched_directory: {
    type: 'envoy.config.core.v3.WatchedDirectory',
    allowedNames: [
      'watched_directory',
      'watchedDirectory',
    ],
  },
};
local oneOfs = [];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    TrustChainVerification:: (import 'certificate-validation-context-trust-chain-verification.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAllowExpiredCertificate:: function(val) validator.validateField(self + { allow_expired_certificate: val }, 'allow_expired_certificate', type + '.withAllowExpiredCertificate'),
    withCaCertificateProviderInstance:: function(val) validator.validateField(self + { ca_certificate_provider_instance: val }, 'ca_certificate_provider_instance', type + '.withCaCertificateProviderInstance'),
    withCrl:: function(val) validator.validateField(self + { crl: val }, 'crl', type + '.withCrl'),
    withCustomValidatorConfig:: function(val) validator.validateField(self + { custom_validator_config: val }, 'custom_validator_config', type + '.withCustomValidatorConfig'),
    withMatchSubjectAltNames:: function(val) validator.validateField(self + { match_subject_alt_names: val }, 'match_subject_alt_names', type + '.withMatchSubjectAltNames'),
    withMatchTypedSubjectAltNames:: function(val) validator.validateField(self + { match_typed_subject_alt_names: val }, 'match_typed_subject_alt_names', type + '.withMatchTypedSubjectAltNames'),
    withMaxVerifyDepth:: function(val) validator.validateField(self + { max_verify_depth: val }, 'max_verify_depth', type + '.withMaxVerifyDepth'),
    withOnlyVerifyLeafCertCrl:: function(val) validator.validateField(self + { only_verify_leaf_cert_crl: val }, 'only_verify_leaf_cert_crl', type + '.withOnlyVerifyLeafCertCrl'),
    withRequireSignedCertificateTimestamp:: function(val) validator.validateField(self + { require_signed_certificate_timestamp: val }, 'require_signed_certificate_timestamp', type + '.withRequireSignedCertificateTimestamp'),
    withTrustChainVerification:: function(val) validator.validateField(self + { trust_chain_verification: val }, 'trust_chain_verification', type + '.withTrustChainVerification'),
    withTrustedCa:: function(val) validator.validateField(self + { trusted_ca: val }, 'trusted_ca', type + '.withTrustedCa'),
    withVerifyCertificateHash:: function(val) validator.validateField(self + { verify_certificate_hash: val }, 'verify_certificate_hash', type + '.withVerifyCertificateHash'),
    withVerifyCertificateSpki:: function(val) validator.validateField(self + { verify_certificate_spki: val }, 'verify_certificate_spki', type + '.withVerifyCertificateSpki'),
    withWatchedDirectory:: function(val) validator.validateField(self + { watched_directory: val }, 'watched_directory', type + '.withWatchedDirectory'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
