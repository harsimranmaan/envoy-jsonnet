// Message type: envoy.extensions.transport_sockets.tls.v3.TlsParameters
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.extensions.transport_sockets.tls.v3.TlsParameters';
local generator = import '../generator.libsonnet';
local fields = {
  cipher_suites: {
    type: 'string',
    allowedNames: [
      'cipher_suites',
      'cipherSuites',
    ],
    containerType: 'list',
  },
  ecdh_curves: {
    type: 'string',
    allowedNames: [
      'ecdh_curves',
      'ecdhCurves',
    ],
    containerType: 'list',
  },
  tls_maximum_protocol_version: {
    type: 'envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol',
    allowedNames: [
      'tls_maximum_protocol_version',
      'tlsMaximumProtocolVersion',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  tls_minimum_protocol_version: {
    type: 'envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol',
    allowedNames: [
      'tls_minimum_protocol_version',
      'tlsMinimumProtocolVersion',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
};
local oneOfs = [];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    TlsProtocol:: (import 'tls-parameters-tls-protocol.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withCipherSuites:: function(val) validator.validateField(self + { cipher_suites: val }, 'cipher_suites', type + '.withCipherSuites'),
    withEcdhCurves:: function(val) validator.validateField(self + { ecdh_curves: val }, 'ecdh_curves', type + '.withEcdhCurves'),
    withTlsMaximumProtocolVersion:: function(val) validator.validateField(self + { tls_maximum_protocol_version: val }, 'tls_maximum_protocol_version', type + '.withTlsMaximumProtocolVersion'),
    withTlsMinimumProtocolVersion:: function(val) validator.validateField(self + { tls_minimum_protocol_version: val }, 'tls_minimum_protocol_version', type + '.withTlsMinimumProtocolVersion'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
