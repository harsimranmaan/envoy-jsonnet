// Message type: envoy.extensions.filters.http.oauth2.v3.OAuth2Config
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.extensions.filters.http.oauth2.v3.OAuth2Config';
local generator = import '../generator.libsonnet';
local fields = {
  auth_scopes: {
    type: 'string',
    allowedNames: [
      'auth_scopes',
      'authScopes',
    ],
    containerType: 'list',
  },
  auth_type: {
    type: 'envoy.extensions.filters.http.oauth2.v3.OAuth2Config.AuthType',
    allowedNames: [
      'auth_type',
      'authType',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  authorization_endpoint: {
    type: 'string',
    allowedNames: [
      'authorization_endpoint',
      'authorizationEndpoint',
    ],
    constraints: {
      String_: {
        WellKnown: null,
        min_len: 1,
      },
    },
  },
  credentials: {
    type: 'envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials',
    allowedNames: [
      'credentials',
    ],
    required: true,
  },
  forward_bearer_token: {
    type: 'bool',
    allowedNames: [
      'forward_bearer_token',
      'forwardBearerToken',
    ],
  },
  pass_through_matcher: {
    type: 'envoy.config.route.v3.HeaderMatcher',
    allowedNames: [
      'pass_through_matcher',
      'passThroughMatcher',
    ],
    containerType: 'list',
  },
  redirect_path_matcher: {
    type: 'envoy.type.matcher.v3.PathMatcher',
    allowedNames: [
      'redirect_path_matcher',
      'redirectPathMatcher',
    ],
    required: true,
  },
  redirect_uri: {
    type: 'string',
    allowedNames: [
      'redirect_uri',
      'redirectUri',
    ],
    constraints: {
      String_: {
        WellKnown: null,
        min_len: 1,
      },
    },
  },
  resources: {
    type: 'string',
    allowedNames: [
      'resources',
    ],
    containerType: 'list',
  },
  signout_path: {
    type: 'envoy.type.matcher.v3.PathMatcher',
    allowedNames: [
      'signout_path',
      'signoutPath',
    ],
    required: true,
  },
  token_endpoint: {
    type: 'envoy.config.core.v3.HttpUri',
    allowedNames: [
      'token_endpoint',
      'tokenEndpoint',
    ],
  },
};
local oneOfs = [];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    AuthType:: (import 'o-auth-2-config-auth-type.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAuthScopes:: function(val) validator.validateField(self + { auth_scopes: val }, 'auth_scopes', type + '.withAuthScopes'),
    withAuthType:: function(val) validator.validateField(self + { auth_type: val }, 'auth_type', type + '.withAuthType'),
    withAuthorizationEndpoint:: function(val) validator.validateField(self + { authorization_endpoint: val }, 'authorization_endpoint', type + '.withAuthorizationEndpoint'),
    withCredentials:: function(val) validator.validateField(self + { credentials: val }, 'credentials', type + '.withCredentials'),
    withForwardBearerToken:: function(val) validator.validateField(self + { forward_bearer_token: val }, 'forward_bearer_token', type + '.withForwardBearerToken'),
    withPassThroughMatcher:: function(val) validator.validateField(self + { pass_through_matcher: val }, 'pass_through_matcher', type + '.withPassThroughMatcher'),
    withRedirectPathMatcher:: function(val) validator.validateField(self + { redirect_path_matcher: val }, 'redirect_path_matcher', type + '.withRedirectPathMatcher'),
    withRedirectUri:: function(val) validator.validateField(self + { redirect_uri: val }, 'redirect_uri', type + '.withRedirectUri'),
    withResources:: function(val) validator.validateField(self + { resources: val }, 'resources', type + '.withResources'),
    withSignoutPath:: function(val) validator.validateField(self + { signout_path: val }, 'signout_path', type + '.withSignoutPath'),
    withTokenEndpoint:: function(val) validator.validateField(self + { token_endpoint: val }, 'token_endpoint', type + '.withTokenEndpoint'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
