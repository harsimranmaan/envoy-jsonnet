// Message type: envoy.config.listener.v3.FilterChainMatch
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.listener.v3.FilterChainMatch';
local generator = import '../generator.libsonnet';
local fields = {
  address_suffix: {
    type: 'string',
    allowedNames: [
      'address_suffix',
      'addressSuffix',
    ],
  },
  application_protocols: {
    type: 'string',
    allowedNames: [
      'application_protocols',
      'applicationProtocols',
    ],
    containerType: 'list',
  },
  destination_port: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'destination_port',
      'destinationPort',
    ],
    constraints: {
      Uint32: {
        gte: 1,
        lte: 65535,
      },
    },
  },
  direct_source_prefix_ranges: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'direct_source_prefix_ranges',
      'directSourcePrefixRanges',
    ],
    containerType: 'list',
  },
  prefix_ranges: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'prefix_ranges',
      'prefixRanges',
    ],
    containerType: 'list',
  },
  server_names: {
    type: 'string',
    allowedNames: [
      'server_names',
      'serverNames',
    ],
    containerType: 'list',
  },
  source_ports: {
    type: 'uint32',
    allowedNames: [
      'source_ports',
      'sourcePorts',
    ],
    containerType: 'list',
    constraints: {
      Repeated: {
        items: {
          Type: {
            Uint32: {
              gte: 1,
              lte: 65535,
            },
          },
        },
      },
    },
  },
  source_prefix_ranges: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'source_prefix_ranges',
      'sourcePrefixRanges',
    ],
    containerType: 'list',
  },
  source_type: {
    type: 'envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType',
    allowedNames: [
      'source_type',
      'sourceType',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  suffix_len: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'suffix_len',
      'suffixLen',
    ],
  },
  transport_protocol: {
    type: 'string',
    allowedNames: [
      'transport_protocol',
      'transportProtocol',
    ],
  },
};
local oneOfs = [];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    ConnectionSourceType:: (import 'filter-chain-match-connection-source-type.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAddressSuffix:: function(val) validator.validateField(self + { address_suffix: val }, 'address_suffix', type + '.withAddressSuffix'),
    withApplicationProtocols:: function(val) validator.validateField(self + { application_protocols: val }, 'application_protocols', type + '.withApplicationProtocols'),
    withDestinationPort:: function(val) validator.validateField(self + { destination_port: val }, 'destination_port', type + '.withDestinationPort'),
    withDirectSourcePrefixRanges:: function(val) validator.validateField(self + { direct_source_prefix_ranges: val }, 'direct_source_prefix_ranges', type + '.withDirectSourcePrefixRanges'),
    withPrefixRanges:: function(val) validator.validateField(self + { prefix_ranges: val }, 'prefix_ranges', type + '.withPrefixRanges'),
    withServerNames:: function(val) validator.validateField(self + { server_names: val }, 'server_names', type + '.withServerNames'),
    withSourcePorts:: function(val) validator.validateField(self + { source_ports: val }, 'source_ports', type + '.withSourcePorts'),
    withSourcePrefixRanges:: function(val) validator.validateField(self + { source_prefix_ranges: val }, 'source_prefix_ranges', type + '.withSourcePrefixRanges'),
    withSourceType:: function(val) validator.validateField(self + { source_type: val }, 'source_type', type + '.withSourceType'),
    withSuffixLen:: function(val) validator.validateField(self + { suffix_len: val }, 'suffix_len', type + '.withSuffixLen'),
    withTransportProtocol:: function(val) validator.validateField(self + { transport_protocol: val }, 'transport_protocol', type + '.withTransportProtocol'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
