// Message type: envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit';
local generator = import '../generator.libsonnet';
local fields = {
  descriptors: {
    type: 'envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor',
    allowedNames: [
      'descriptors',
    ],
    containerType: 'list',
  },
  enable_x_ratelimit_headers: {
    type: 'envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion',
    allowedNames: [
      'enable_x_ratelimit_headers',
      'enableXRatelimitHeaders',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  filter_enabled: {
    type: 'envoy.config.core.v3.RuntimeFractionalPercent',
    allowedNames: [
      'filter_enabled',
      'filterEnabled',
    ],
  },
  filter_enforced: {
    type: 'envoy.config.core.v3.RuntimeFractionalPercent',
    allowedNames: [
      'filter_enforced',
      'filterEnforced',
    ],
  },
  local_rate_limit_per_downstream_connection: {
    type: 'bool',
    allowedNames: [
      'local_rate_limit_per_downstream_connection',
      'localRateLimitPerDownstreamConnection',
    ],
  },
  request_headers_to_add_when_not_enforced: {
    type: 'envoy.config.core.v3.HeaderValueOption',
    allowedNames: [
      'request_headers_to_add_when_not_enforced',
      'requestHeadersToAddWhenNotEnforced',
    ],
    containerType: 'list',
    constraints: {
      Repeated: {
        max_items: 10,
      },
    },
  },
  response_headers_to_add: {
    type: 'envoy.config.core.v3.HeaderValueOption',
    allowedNames: [
      'response_headers_to_add',
      'responseHeadersToAdd',
    ],
    containerType: 'list',
    constraints: {
      Repeated: {
        max_items: 10,
      },
    },
  },
  stage: {
    type: 'uint32',
    allowedNames: [
      'stage',
    ],
    constraints: {
      Uint32: {
        lte: 10,
      },
    },
  },
  stat_prefix: {
    type: 'string',
    allowedNames: [
      'stat_prefix',
      'statPrefix',
    ],
    constraints: {
      String_: {
        WellKnown: null,
        min_len: 1,
      },
    },
  },
  status: {
    type: 'envoy.type.v3.HttpStatus',
    allowedNames: [
      'status',
    ],
  },
  token_bucket: {
    type: 'envoy.type.v3.TokenBucket',
    allowedNames: [
      'token_bucket',
      'tokenBucket',
    ],
  },
  vh_rate_limits: {
    type: 'envoy.extensions.common.ratelimit.v3.VhRateLimitsOptions',
    allowedNames: [
      'vh_rate_limits',
      'vhRateLimits',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
};
local oneOfs = [];
local validator = generator(type, fields, oneOfs);

{
  definition: {

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withDescriptors:: function(val) validator.validateField(self + { descriptors: val }, 'descriptors', type + '.withDescriptors'),
    withEnableXRatelimitHeaders:: function(val) validator.validateField(self + { enable_x_ratelimit_headers: val }, 'enable_x_ratelimit_headers', type + '.withEnableXRatelimitHeaders'),
    withFilterEnabled:: function(val) validator.validateField(self + { filter_enabled: val }, 'filter_enabled', type + '.withFilterEnabled'),
    withFilterEnforced:: function(val) validator.validateField(self + { filter_enforced: val }, 'filter_enforced', type + '.withFilterEnforced'),
    withLocalRateLimitPerDownstreamConnection:: function(val) validator.validateField(self + { local_rate_limit_per_downstream_connection: val }, 'local_rate_limit_per_downstream_connection', type + '.withLocalRateLimitPerDownstreamConnection'),
    withRequestHeadersToAddWhenNotEnforced:: function(val) validator.validateField(self + { request_headers_to_add_when_not_enforced: val }, 'request_headers_to_add_when_not_enforced', type + '.withRequestHeadersToAddWhenNotEnforced'),
    withResponseHeadersToAdd:: function(val) validator.validateField(self + { response_headers_to_add: val }, 'response_headers_to_add', type + '.withResponseHeadersToAdd'),
    withStage:: function(val) validator.validateField(self + { stage: val }, 'stage', type + '.withStage'),
    withStatPrefix:: function(val) validator.validateField(self + { stat_prefix: val }, 'stat_prefix', type + '.withStatPrefix'),
    withStatus:: function(val) validator.validateField(self + { status: val }, 'status', type + '.withStatus'),
    withTokenBucket:: function(val) validator.validateField(self + { token_bucket: val }, 'token_bucket', type + '.withTokenBucket'),
    withVhRateLimits:: function(val) validator.validateField(self + { vh_rate_limits: val }, 'vh_rate_limits', type + '.withVhRateLimits'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
