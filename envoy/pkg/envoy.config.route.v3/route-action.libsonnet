// Message type: envoy.config.route.v3.RouteAction
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.route.v3.RouteAction';
local generator = import '../generator.libsonnet';
local fields = {
  append_x_forwarded_host: {
    type: 'bool',
    allowedNames: [
      'append_x_forwarded_host',
      'appendXForwardedHost',
    ],
  },
  auto_host_rewrite: {
    type: 'google.protobuf.BoolValue',
    allowedNames: [
      'auto_host_rewrite',
      'autoHostRewrite',
    ],
  },
  cluster: {
    type: 'string',
    allowedNames: [
      'cluster',
    ],
    constraints: {
      String_: {
        WellKnown: null,
        min_len: 1,
      },
    },
  },
  cluster_header: {
    type: 'string',
    allowedNames: [
      'cluster_header',
      'clusterHeader',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 1,
        },
        min_len: 1,
        strict: false,
      },
    },
  },
  cluster_not_found_response_code: {
    type: 'envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode',
    allowedNames: [
      'cluster_not_found_response_code',
      'clusterNotFoundResponseCode',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  cluster_specifier_plugin: {
    type: 'string',
    allowedNames: [
      'cluster_specifier_plugin',
      'clusterSpecifierPlugin',
    ],
  },
  cors: {
    type: 'envoy.config.route.v3.CorsPolicy',
    allowedNames: [
      'cors',
    ],
  },
  early_data_policy: {
    type: 'envoy.config.core.v3.TypedExtensionConfig',
    allowedNames: [
      'early_data_policy',
      'earlyDataPolicy',
    ],
  },
  grpc_timeout_offset: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'grpc_timeout_offset',
      'grpcTimeoutOffset',
    ],
  },
  hash_policy: {
    type: 'envoy.config.route.v3.RouteAction.HashPolicy',
    allowedNames: [
      'hash_policy',
      'hashPolicy',
    ],
    containerType: 'list',
  },
  hedge_policy: {
    type: 'envoy.config.route.v3.HedgePolicy',
    allowedNames: [
      'hedge_policy',
      'hedgePolicy',
    ],
  },
  host_rewrite_header: {
    type: 'string',
    allowedNames: [
      'host_rewrite_header',
      'hostRewriteHeader',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 1,
        },
        strict: false,
      },
    },
  },
  host_rewrite_literal: {
    type: 'string',
    allowedNames: [
      'host_rewrite_literal',
      'hostRewriteLiteral',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 2,
        },
        strict: false,
      },
    },
  },
  host_rewrite_path_regex: {
    type: 'envoy.type.matcher.v3.RegexMatchAndSubstitute',
    allowedNames: [
      'host_rewrite_path_regex',
      'hostRewritePathRegex',
    ],
  },
  idle_timeout: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'idle_timeout',
      'idleTimeout',
    ],
  },
  include_vh_rate_limits: {
    type: 'google.protobuf.BoolValue',
    allowedNames: [
      'include_vh_rate_limits',
      'includeVhRateLimits',
    ],
  },
  inline_cluster_specifier_plugin: {
    type: 'envoy.config.route.v3.ClusterSpecifierPlugin',
    allowedNames: [
      'inline_cluster_specifier_plugin',
      'inlineClusterSpecifierPlugin',
    ],
  },
  internal_redirect_action: {
    type: 'envoy.config.route.v3.RouteAction.InternalRedirectAction',
    allowedNames: [
      'internal_redirect_action',
      'internalRedirectAction',
    ],
  },
  internal_redirect_policy: {
    type: 'envoy.config.route.v3.InternalRedirectPolicy',
    allowedNames: [
      'internal_redirect_policy',
      'internalRedirectPolicy',
    ],
  },
  max_grpc_timeout: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'max_grpc_timeout',
      'maxGrpcTimeout',
    ],
  },
  max_internal_redirects: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'max_internal_redirects',
      'maxInternalRedirects',
    ],
  },
  max_stream_duration: {
    type: 'envoy.config.route.v3.RouteAction.MaxStreamDuration',
    allowedNames: [
      'max_stream_duration',
      'maxStreamDuration',
    ],
  },
  metadata_match: {
    type: 'envoy.config.core.v3.Metadata',
    allowedNames: [
      'metadata_match',
      'metadataMatch',
    ],
  },
  path_rewrite_policy: {
    type: 'envoy.config.core.v3.TypedExtensionConfig',
    allowedNames: [
      'path_rewrite_policy',
      'pathRewritePolicy',
    ],
  },
  prefix_rewrite: {
    type: 'string',
    allowedNames: [
      'prefix_rewrite',
      'prefixRewrite',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 2,
        },
        strict: false,
      },
    },
  },
  priority: {
    type: 'envoy.config.core.v3.RoutingPriority',
    allowedNames: [
      'priority',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  rate_limits: {
    type: 'envoy.config.route.v3.RateLimit',
    allowedNames: [
      'rate_limits',
      'rateLimits',
    ],
    containerType: 'list',
  },
  regex_rewrite: {
    type: 'envoy.type.matcher.v3.RegexMatchAndSubstitute',
    allowedNames: [
      'regex_rewrite',
      'regexRewrite',
    ],
  },
  request_mirror_policies: {
    type: 'envoy.config.route.v3.RouteAction.RequestMirrorPolicy',
    allowedNames: [
      'request_mirror_policies',
      'requestMirrorPolicies',
    ],
    containerType: 'list',
  },
  retry_policy: {
    type: 'envoy.config.route.v3.RetryPolicy',
    allowedNames: [
      'retry_policy',
      'retryPolicy',
    ],
  },
  retry_policy_typed_config: {
    type: 'google.protobuf.Any',
    allowedNames: [
      'retry_policy_typed_config',
      'retryPolicyTypedConfig',
    ],
  },
  timeout: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'timeout',
    ],
  },
  upgrade_configs: {
    type: 'envoy.config.route.v3.RouteAction.UpgradeConfig',
    allowedNames: [
      'upgrade_configs',
      'upgradeConfigs',
    ],
    containerType: 'list',
  },
  weighted_clusters: {
    type: 'envoy.config.route.v3.WeightedCluster',
    allowedNames: [
      'weighted_clusters',
      'weightedClusters',
    ],
  },
};
local oneOfs = [
  {
    fields: [
      'cluster',
      'cluster_header',
      'weighted_clusters',
      'cluster_specifier_plugin',
      'inline_cluster_specifier_plugin',
    ],
    required: true,
    group: 'cluster_specifier',
  },
  {
    fields: [
      'host_rewrite_literal',
      'auto_host_rewrite',
      'host_rewrite_header',
      'host_rewrite_path_regex',
    ],
    required: false,
    group: 'host_rewrite_specifier',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    ClusterNotFoundResponseCode:: (import 'route-action-cluster-not-found-response-code.libsonnet').definition,
    InternalRedirectAction:: (import 'route-action-internal-redirect-action.libsonnet').definition,
    RequestMirrorPolicy:: (import 'route-action-request-mirror-policy.libsonnet').definition,
    HashPolicy:: (import 'route-action-hash-policy.libsonnet').definition,
    UpgradeConfig:: (import 'route-action-upgrade-config.libsonnet').definition,
    MaxStreamDuration:: (import 'route-action-max-stream-duration.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAppendXForwardedHost:: function(val) validator.validateField(self + { append_x_forwarded_host: val }, 'append_x_forwarded_host', type + '.withAppendXForwardedHost'),
    withAutoHostRewrite:: function(val) validator.validateField(self + { auto_host_rewrite: val }, 'auto_host_rewrite', type + '.withAutoHostRewrite'),
    withCluster:: function(val) validator.validateField(self + { cluster: val }, 'cluster', type + '.withCluster'),
    withClusterHeader:: function(val) validator.validateField(self + { cluster_header: val }, 'cluster_header', type + '.withClusterHeader'),
    withClusterNotFoundResponseCode:: function(val) validator.validateField(self + { cluster_not_found_response_code: val }, 'cluster_not_found_response_code', type + '.withClusterNotFoundResponseCode'),
    withClusterSpecifierPlugin:: function(val) validator.validateField(self + { cluster_specifier_plugin: val }, 'cluster_specifier_plugin', type + '.withClusterSpecifierPlugin'),
    withCors:: function(val) validator.validateField(self + { cors: val }, 'cors', type + '.withCors'),
    withEarlyDataPolicy:: function(val) validator.validateField(self + { early_data_policy: val }, 'early_data_policy', type + '.withEarlyDataPolicy'),
    withGrpcTimeoutOffset:: function(val) validator.validateField(self + { grpc_timeout_offset: val }, 'grpc_timeout_offset', type + '.withGrpcTimeoutOffset'),
    withHashPolicy:: function(val) validator.validateField(self + { hash_policy: val }, 'hash_policy', type + '.withHashPolicy'),
    withHedgePolicy:: function(val) validator.validateField(self + { hedge_policy: val }, 'hedge_policy', type + '.withHedgePolicy'),
    withHostRewriteHeader:: function(val) validator.validateField(self + { host_rewrite_header: val }, 'host_rewrite_header', type + '.withHostRewriteHeader'),
    withHostRewriteLiteral:: function(val) validator.validateField(self + { host_rewrite_literal: val }, 'host_rewrite_literal', type + '.withHostRewriteLiteral'),
    withHostRewritePathRegex:: function(val) validator.validateField(self + { host_rewrite_path_regex: val }, 'host_rewrite_path_regex', type + '.withHostRewritePathRegex'),
    withIdleTimeout:: function(val) validator.validateField(self + { idle_timeout: val }, 'idle_timeout', type + '.withIdleTimeout'),
    withIncludeVhRateLimits:: function(val) validator.validateField(self + { include_vh_rate_limits: val }, 'include_vh_rate_limits', type + '.withIncludeVhRateLimits'),
    withInlineClusterSpecifierPlugin:: function(val) validator.validateField(self + { inline_cluster_specifier_plugin: val }, 'inline_cluster_specifier_plugin', type + '.withInlineClusterSpecifierPlugin'),
    withInternalRedirectAction:: function(val) validator.validateField(self + { internal_redirect_action: val }, 'internal_redirect_action', type + '.withInternalRedirectAction'),
    withInternalRedirectPolicy:: function(val) validator.validateField(self + { internal_redirect_policy: val }, 'internal_redirect_policy', type + '.withInternalRedirectPolicy'),
    withMaxGrpcTimeout:: function(val) validator.validateField(self + { max_grpc_timeout: val }, 'max_grpc_timeout', type + '.withMaxGrpcTimeout'),
    withMaxInternalRedirects:: function(val) validator.validateField(self + { max_internal_redirects: val }, 'max_internal_redirects', type + '.withMaxInternalRedirects'),
    withMaxStreamDuration:: function(val) validator.validateField(self + { max_stream_duration: val }, 'max_stream_duration', type + '.withMaxStreamDuration'),
    withMetadataMatch:: function(val) validator.validateField(self + { metadata_match: val }, 'metadata_match', type + '.withMetadataMatch'),
    withPathRewritePolicy:: function(val) validator.validateField(self + { path_rewrite_policy: val }, 'path_rewrite_policy', type + '.withPathRewritePolicy'),
    withPrefixRewrite:: function(val) validator.validateField(self + { prefix_rewrite: val }, 'prefix_rewrite', type + '.withPrefixRewrite'),
    withPriority:: function(val) validator.validateField(self + { priority: val }, 'priority', type + '.withPriority'),
    withRateLimits:: function(val) validator.validateField(self + { rate_limits: val }, 'rate_limits', type + '.withRateLimits'),
    withRegexRewrite:: function(val) validator.validateField(self + { regex_rewrite: val }, 'regex_rewrite', type + '.withRegexRewrite'),
    withRequestMirrorPolicies:: function(val) validator.validateField(self + { request_mirror_policies: val }, 'request_mirror_policies', type + '.withRequestMirrorPolicies'),
    withRetryPolicy:: function(val) validator.validateField(self + { retry_policy: val }, 'retry_policy', type + '.withRetryPolicy'),
    withRetryPolicyTypedConfig:: function(val) validator.validateField(self + { retry_policy_typed_config: val }, 'retry_policy_typed_config', type + '.withRetryPolicyTypedConfig'),
    withTimeout:: function(val) validator.validateField(self + { timeout: val }, 'timeout', type + '.withTimeout'),
    withUpgradeConfigs:: function(val) validator.validateField(self + { upgrade_configs: val }, 'upgrade_configs', type + '.withUpgradeConfigs'),
    withWeightedClusters:: function(val) validator.validateField(self + { weighted_clusters: val }, 'weighted_clusters', type + '.withWeightedClusters'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
