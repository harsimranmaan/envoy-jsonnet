// Message type: envoy.config.route.v3.RetryPolicy
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.route.v3.RetryPolicy';
local generator = import '../generator.libsonnet';
local fields = {
  host_selection_retry_max_attempts: {
    type: 'int64',
    allowedNames: [
      'host_selection_retry_max_attempts',
      'hostSelectionRetryMaxAttempts',
    ],
  },
  num_retries: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'num_retries',
      'numRetries',
    ],
  },
  per_try_idle_timeout: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'per_try_idle_timeout',
      'perTryIdleTimeout',
    ],
  },
  per_try_timeout: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'per_try_timeout',
      'perTryTimeout',
    ],
  },
  rate_limited_retry_back_off: {
    type: 'envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff',
    allowedNames: [
      'rate_limited_retry_back_off',
      'rateLimitedRetryBackOff',
    ],
  },
  retriable_headers: {
    type: 'envoy.config.route.v3.HeaderMatcher',
    allowedNames: [
      'retriable_headers',
      'retriableHeaders',
    ],
    containerType: 'list',
  },
  retriable_request_headers: {
    type: 'envoy.config.route.v3.HeaderMatcher',
    allowedNames: [
      'retriable_request_headers',
      'retriableRequestHeaders',
    ],
    containerType: 'list',
  },
  retriable_status_codes: {
    type: 'uint32',
    allowedNames: [
      'retriable_status_codes',
      'retriableStatusCodes',
    ],
    containerType: 'list',
  },
  retry_back_off: {
    type: 'envoy.config.route.v3.RetryPolicy.RetryBackOff',
    allowedNames: [
      'retry_back_off',
      'retryBackOff',
    ],
  },
  retry_host_predicate: {
    type: 'envoy.config.route.v3.RetryPolicy.RetryHostPredicate',
    allowedNames: [
      'retry_host_predicate',
      'retryHostPredicate',
    ],
    containerType: 'list',
  },
  retry_on: {
    type: 'string',
    allowedNames: [
      'retry_on',
      'retryOn',
    ],
  },
  retry_options_predicates: {
    type: 'envoy.config.core.v3.TypedExtensionConfig',
    allowedNames: [
      'retry_options_predicates',
      'retryOptionsPredicates',
    ],
    containerType: 'list',
  },
  retry_priority: {
    type: 'envoy.config.route.v3.RetryPolicy.RetryPriority',
    allowedNames: [
      'retry_priority',
      'retryPriority',
    ],
  },
};
local oneOfs = [];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    ResetHeaderFormat:: (import 'retry-policy-reset-header-format.libsonnet').definition,
    RetryPriority:: (import 'retry-policy-retry-priority.libsonnet').definition,
    RetryHostPredicate:: (import 'retry-policy-retry-host-predicate.libsonnet').definition,
    RetryBackOff:: (import 'retry-policy-retry-back-off.libsonnet').definition,
    ResetHeader:: (import 'retry-policy-reset-header.libsonnet').definition,
    RateLimitedRetryBackOff:: (import 'retry-policy-rate-limited-retry-back-off.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withHostSelectionRetryMaxAttempts:: function(val) validator.validateField(self + { host_selection_retry_max_attempts: val }, 'host_selection_retry_max_attempts', type + '.withHostSelectionRetryMaxAttempts'),
    withNumRetries:: function(val) validator.validateField(self + { num_retries: val }, 'num_retries', type + '.withNumRetries'),
    withPerTryIdleTimeout:: function(val) validator.validateField(self + { per_try_idle_timeout: val }, 'per_try_idle_timeout', type + '.withPerTryIdleTimeout'),
    withPerTryTimeout:: function(val) validator.validateField(self + { per_try_timeout: val }, 'per_try_timeout', type + '.withPerTryTimeout'),
    withRateLimitedRetryBackOff:: function(val) validator.validateField(self + { rate_limited_retry_back_off: val }, 'rate_limited_retry_back_off', type + '.withRateLimitedRetryBackOff'),
    withRetriableHeaders:: function(val) validator.validateField(self + { retriable_headers: val }, 'retriable_headers', type + '.withRetriableHeaders'),
    withRetriableRequestHeaders:: function(val) validator.validateField(self + { retriable_request_headers: val }, 'retriable_request_headers', type + '.withRetriableRequestHeaders'),
    withRetriableStatusCodes:: function(val) validator.validateField(self + { retriable_status_codes: val }, 'retriable_status_codes', type + '.withRetriableStatusCodes'),
    withRetryBackOff:: function(val) validator.validateField(self + { retry_back_off: val }, 'retry_back_off', type + '.withRetryBackOff'),
    withRetryHostPredicate:: function(val) validator.validateField(self + { retry_host_predicate: val }, 'retry_host_predicate', type + '.withRetryHostPredicate'),
    withRetryOn:: function(val) validator.validateField(self + { retry_on: val }, 'retry_on', type + '.withRetryOn'),
    withRetryOptionsPredicates:: function(val) validator.validateField(self + { retry_options_predicates: val }, 'retry_options_predicates', type + '.withRetryOptionsPredicates'),
    withRetryPriority:: function(val) validator.validateField(self + { retry_priority: val }, 'retry_priority', type + '.withRetryPriority'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
