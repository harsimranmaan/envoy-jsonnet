// Message type: envoy.config.route.v3.RedirectAction
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.route.v3.RedirectAction';
local generator = import '../generator.libsonnet';
local fields = {
  host_redirect: {
    type: 'string',
    allowedNames: [
      'host_redirect',
      'hostRedirect',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 2,
        },
        strict: false,
      },
    },
  },
  https_redirect: {
    type: 'bool',
    allowedNames: [
      'https_redirect',
      'httpsRedirect',
    ],
  },
  path_redirect: {
    type: 'string',
    allowedNames: [
      'path_redirect',
      'pathRedirect',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 2,
        },
        strict: false,
      },
    },
  },
  port_redirect: {
    type: 'uint32',
    allowedNames: [
      'port_redirect',
      'portRedirect',
    ],
  },
  prefix_rewrite: {
    type: 'string',
    allowedNames: [
      'prefix_rewrite',
      'prefixRewrite',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 2,
        },
        strict: false,
      },
    },
  },
  regex_rewrite: {
    type: 'envoy.type.matcher.v3.RegexMatchAndSubstitute',
    allowedNames: [
      'regex_rewrite',
      'regexRewrite',
    ],
  },
  response_code: {
    type: 'envoy.config.route.v3.RedirectAction.RedirectResponseCode',
    allowedNames: [
      'response_code',
      'responseCode',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
  scheme_redirect: {
    type: 'string',
    allowedNames: [
      'scheme_redirect',
      'schemeRedirect',
    ],
  },
  strip_query: {
    type: 'bool',
    allowedNames: [
      'strip_query',
      'stripQuery',
    ],
  },
};
local oneOfs = [
  {
    fields: [
      'https_redirect',
      'scheme_redirect',
    ],
    required: false,
    group: 'scheme_rewrite_specifier',
  },
  {
    fields: [
      'path_redirect',
      'prefix_rewrite',
      'regex_rewrite',
    ],
    required: false,
    group: 'path_rewrite_specifier',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    RedirectResponseCode:: (import 'redirect-action-redirect-response-code.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withHostRedirect:: function(val) validator.validateField(self + { host_redirect: val }, 'host_redirect', type + '.withHostRedirect'),
    withHttpsRedirect:: function(val) validator.validateField(self + { https_redirect: val }, 'https_redirect', type + '.withHttpsRedirect'),
    withPathRedirect:: function(val) validator.validateField(self + { path_redirect: val }, 'path_redirect', type + '.withPathRedirect'),
    withPortRedirect:: function(val) validator.validateField(self + { port_redirect: val }, 'port_redirect', type + '.withPortRedirect'),
    withPrefixRewrite:: function(val) validator.validateField(self + { prefix_rewrite: val }, 'prefix_rewrite', type + '.withPrefixRewrite'),
    withRegexRewrite:: function(val) validator.validateField(self + { regex_rewrite: val }, 'regex_rewrite', type + '.withRegexRewrite'),
    withResponseCode:: function(val) validator.validateField(self + { response_code: val }, 'response_code', type + '.withResponseCode'),
    withSchemeRedirect:: function(val) validator.validateField(self + { scheme_redirect: val }, 'scheme_redirect', type + '.withSchemeRedirect'),
    withStripQuery:: function(val) validator.validateField(self + { strip_query: val }, 'strip_query', type + '.withStripQuery'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
