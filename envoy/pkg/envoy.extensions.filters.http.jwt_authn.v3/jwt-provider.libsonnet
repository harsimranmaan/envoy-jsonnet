// Message type: envoy.extensions.filters.http.jwt_authn.v3.JwtProvider
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.extensions.filters.http.jwt_authn.v3.JwtProvider';
local generator = import '../generator.libsonnet';
local fields = {
  audiences: {
    type: 'string',
    allowedNames: [
      'audiences',
    ],
    containerType: 'list',
  },
  claim_to_headers: {
    type: 'envoy.extensions.filters.http.jwt_authn.v3.JwtClaimToHeader',
    allowedNames: [
      'claim_to_headers',
      'claimToHeaders',
    ],
    containerType: 'list',
  },
  clock_skew_seconds: {
    type: 'uint32',
    allowedNames: [
      'clock_skew_seconds',
      'clockSkewSeconds',
    ],
  },
  forward: {
    type: 'bool',
    allowedNames: [
      'forward',
    ],
  },
  forward_payload_header: {
    type: 'string',
    allowedNames: [
      'forward_payload_header',
      'forwardPayloadHeader',
    ],
    constraints: {
      String_: {
        WellKnown: {
          WellKnownRegex: 1,
        },
        strict: false,
      },
    },
  },
  from_cookies: {
    type: 'string',
    allowedNames: [
      'from_cookies',
      'fromCookies',
    ],
    containerType: 'list',
  },
  from_headers: {
    type: 'envoy.extensions.filters.http.jwt_authn.v3.JwtHeader',
    allowedNames: [
      'from_headers',
      'fromHeaders',
    ],
    containerType: 'list',
  },
  from_params: {
    type: 'string',
    allowedNames: [
      'from_params',
      'fromParams',
    ],
    containerType: 'list',
  },
  header_in_metadata: {
    type: 'string',
    allowedNames: [
      'header_in_metadata',
      'headerInMetadata',
    ],
  },
  issuer: {
    type: 'string',
    allowedNames: [
      'issuer',
    ],
  },
  jwt_cache_config: {
    type: 'envoy.extensions.filters.http.jwt_authn.v3.JwtCacheConfig',
    allowedNames: [
      'jwt_cache_config',
      'jwtCacheConfig',
    ],
  },
  local_jwks: {
    type: 'envoy.config.core.v3.DataSource',
    allowedNames: [
      'local_jwks',
      'localJwks',
    ],
  },
  pad_forward_payload_header: {
    type: 'bool',
    allowedNames: [
      'pad_forward_payload_header',
      'padForwardPayloadHeader',
    ],
  },
  payload_in_metadata: {
    type: 'string',
    allowedNames: [
      'payload_in_metadata',
      'payloadInMetadata',
    ],
  },
  remote_jwks: {
    type: 'envoy.extensions.filters.http.jwt_authn.v3.RemoteJwks',
    allowedNames: [
      'remote_jwks',
      'remoteJwks',
    ],
  },
};
local oneOfs = [
  {
    fields: [
      'remote_jwks',
      'local_jwks',
    ],
    required: true,
    group: 'jwks_source_specifier',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAudiences:: function(val) validator.validateField(self + { audiences: val }, 'audiences', type + '.withAudiences'),
    withClaimToHeaders:: function(val) validator.validateField(self + { claim_to_headers: val }, 'claim_to_headers', type + '.withClaimToHeaders'),
    withClockSkewSeconds:: function(val) validator.validateField(self + { clock_skew_seconds: val }, 'clock_skew_seconds', type + '.withClockSkewSeconds'),
    withForward:: function(val) validator.validateField(self + { forward: val }, 'forward', type + '.withForward'),
    withForwardPayloadHeader:: function(val) validator.validateField(self + { forward_payload_header: val }, 'forward_payload_header', type + '.withForwardPayloadHeader'),
    withFromCookies:: function(val) validator.validateField(self + { from_cookies: val }, 'from_cookies', type + '.withFromCookies'),
    withFromHeaders:: function(val) validator.validateField(self + { from_headers: val }, 'from_headers', type + '.withFromHeaders'),
    withFromParams:: function(val) validator.validateField(self + { from_params: val }, 'from_params', type + '.withFromParams'),
    withHeaderInMetadata:: function(val) validator.validateField(self + { header_in_metadata: val }, 'header_in_metadata', type + '.withHeaderInMetadata'),
    withIssuer:: function(val) validator.validateField(self + { issuer: val }, 'issuer', type + '.withIssuer'),
    withJwtCacheConfig:: function(val) validator.validateField(self + { jwt_cache_config: val }, 'jwt_cache_config', type + '.withJwtCacheConfig'),
    withLocalJwks:: function(val) validator.validateField(self + { local_jwks: val }, 'local_jwks', type + '.withLocalJwks'),
    withPadForwardPayloadHeader:: function(val) validator.validateField(self + { pad_forward_payload_header: val }, 'pad_forward_payload_header', type + '.withPadForwardPayloadHeader'),
    withPayloadInMetadata:: function(val) validator.validateField(self + { payload_in_metadata: val }, 'payload_in_metadata', type + '.withPayloadInMetadata'),
    withRemoteJwks:: function(val) validator.validateField(self + { remote_jwks: val }, 'remote_jwks', type + '.withRemoteJwks'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
