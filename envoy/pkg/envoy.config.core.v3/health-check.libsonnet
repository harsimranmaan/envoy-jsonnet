// Message type: envoy.config.core.v3.HealthCheck
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.core.v3.HealthCheck';
local generator = import '../generator.libsonnet';
local fields = {
  alt_port: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'alt_port',
      'altPort',
    ],
  },
  always_log_health_check_failures: {
    type: 'bool',
    allowedNames: [
      'always_log_health_check_failures',
      'alwaysLogHealthCheckFailures',
    ],
  },
  custom_health_check: {
    type: 'envoy.config.core.v3.HealthCheck.CustomHealthCheck',
    allowedNames: [
      'custom_health_check',
      'customHealthCheck',
    ],
  },
  event_log_path: {
    type: 'string',
    allowedNames: [
      'event_log_path',
      'eventLogPath',
    ],
  },
  event_service: {
    type: 'envoy.config.core.v3.EventServiceConfig',
    allowedNames: [
      'event_service',
      'eventService',
    ],
  },
  grpc_health_check: {
    type: 'envoy.config.core.v3.HealthCheck.GrpcHealthCheck',
    allowedNames: [
      'grpc_health_check',
      'grpcHealthCheck',
    ],
  },
  healthy_edge_interval: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'healthy_edge_interval',
      'healthyEdgeInterval',
    ],
    constraints: {
      Duration: {
        gt: {},
      },
    },
  },
  healthy_threshold: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'healthy_threshold',
      'healthyThreshold',
    ],
    required: true,
  },
  http_health_check: {
    type: 'envoy.config.core.v3.HealthCheck.HttpHealthCheck',
    allowedNames: [
      'http_health_check',
      'httpHealthCheck',
    ],
  },
  initial_jitter: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'initial_jitter',
      'initialJitter',
    ],
  },
  interval: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'interval',
    ],
    constraints: {
      Duration: {
        gt: {},
        required: true,
      },
    },
  },
  interval_jitter: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'interval_jitter',
      'intervalJitter',
    ],
  },
  interval_jitter_percent: {
    type: 'uint32',
    allowedNames: [
      'interval_jitter_percent',
      'intervalJitterPercent',
    ],
  },
  no_traffic_healthy_interval: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'no_traffic_healthy_interval',
      'noTrafficHealthyInterval',
    ],
    constraints: {
      Duration: {
        gt: {},
      },
    },
  },
  no_traffic_interval: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'no_traffic_interval',
      'noTrafficInterval',
    ],
    constraints: {
      Duration: {
        gt: {},
      },
    },
  },
  reuse_connection: {
    type: 'google.protobuf.BoolValue',
    allowedNames: [
      'reuse_connection',
      'reuseConnection',
    ],
  },
  tcp_health_check: {
    type: 'envoy.config.core.v3.HealthCheck.TcpHealthCheck',
    allowedNames: [
      'tcp_health_check',
      'tcpHealthCheck',
    ],
  },
  timeout: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'timeout',
    ],
    constraints: {
      Duration: {
        gt: {},
        required: true,
      },
    },
  },
  tls_options: {
    type: 'envoy.config.core.v3.HealthCheck.TlsOptions',
    allowedNames: [
      'tls_options',
      'tlsOptions',
    ],
  },
  transport_socket_match_criteria: {
    type: 'google.protobuf.Struct',
    allowedNames: [
      'transport_socket_match_criteria',
      'transportSocketMatchCriteria',
    ],
  },
  unhealthy_edge_interval: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'unhealthy_edge_interval',
      'unhealthyEdgeInterval',
    ],
    constraints: {
      Duration: {
        gt: {},
      },
    },
  },
  unhealthy_interval: {
    type: 'google.protobuf.Duration',
    allowedNames: [
      'unhealthy_interval',
      'unhealthyInterval',
    ],
    constraints: {
      Duration: {
        gt: {},
      },
    },
  },
  unhealthy_threshold: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'unhealthy_threshold',
      'unhealthyThreshold',
    ],
    required: true,
  },
};
local oneOfs = [
  {
    fields: [
      'http_health_check',
      'tcp_health_check',
      'grpc_health_check',
      'custom_health_check',
    ],
    required: true,
    group: 'health_checker',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    Payload:: (import 'health-check-payload.libsonnet').definition,
    HttpHealthCheck:: (import 'health-check-http-health-check.libsonnet').definition,
    TcpHealthCheck:: (import 'health-check-tcp-health-check.libsonnet').definition,
    RedisHealthCheck:: (import 'health-check-redis-health-check.libsonnet').definition,
    GrpcHealthCheck:: (import 'health-check-grpc-health-check.libsonnet').definition,
    CustomHealthCheck:: (import 'health-check-custom-health-check.libsonnet').definition,
    TlsOptions:: (import 'health-check-tls-options.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAltPort:: function(val) validator.validateField(self + { alt_port: val }, 'alt_port', type + '.withAltPort'),
    withAlwaysLogHealthCheckFailures:: function(val) validator.validateField(self + { always_log_health_check_failures: val }, 'always_log_health_check_failures', type + '.withAlwaysLogHealthCheckFailures'),
    withCustomHealthCheck:: function(val) validator.validateField(self + { custom_health_check: val }, 'custom_health_check', type + '.withCustomHealthCheck'),
    withEventLogPath:: function(val) validator.validateField(self + { event_log_path: val }, 'event_log_path', type + '.withEventLogPath'),
    withEventService:: function(val) validator.validateField(self + { event_service: val }, 'event_service', type + '.withEventService'),
    withGrpcHealthCheck:: function(val) validator.validateField(self + { grpc_health_check: val }, 'grpc_health_check', type + '.withGrpcHealthCheck'),
    withHealthyEdgeInterval:: function(val) validator.validateField(self + { healthy_edge_interval: val }, 'healthy_edge_interval', type + '.withHealthyEdgeInterval'),
    withHealthyThreshold:: function(val) validator.validateField(self + { healthy_threshold: val }, 'healthy_threshold', type + '.withHealthyThreshold'),
    withHttpHealthCheck:: function(val) validator.validateField(self + { http_health_check: val }, 'http_health_check', type + '.withHttpHealthCheck'),
    withInitialJitter:: function(val) validator.validateField(self + { initial_jitter: val }, 'initial_jitter', type + '.withInitialJitter'),
    withInterval:: function(val) validator.validateField(self + { interval: val }, 'interval', type + '.withInterval'),
    withIntervalJitter:: function(val) validator.validateField(self + { interval_jitter: val }, 'interval_jitter', type + '.withIntervalJitter'),
    withIntervalJitterPercent:: function(val) validator.validateField(self + { interval_jitter_percent: val }, 'interval_jitter_percent', type + '.withIntervalJitterPercent'),
    withNoTrafficHealthyInterval:: function(val) validator.validateField(self + { no_traffic_healthy_interval: val }, 'no_traffic_healthy_interval', type + '.withNoTrafficHealthyInterval'),
    withNoTrafficInterval:: function(val) validator.validateField(self + { no_traffic_interval: val }, 'no_traffic_interval', type + '.withNoTrafficInterval'),
    withReuseConnection:: function(val) validator.validateField(self + { reuse_connection: val }, 'reuse_connection', type + '.withReuseConnection'),
    withTcpHealthCheck:: function(val) validator.validateField(self + { tcp_health_check: val }, 'tcp_health_check', type + '.withTcpHealthCheck'),
    withTimeout:: function(val) validator.validateField(self + { timeout: val }, 'timeout', type + '.withTimeout'),
    withTlsOptions:: function(val) validator.validateField(self + { tls_options: val }, 'tls_options', type + '.withTlsOptions'),
    withTransportSocketMatchCriteria:: function(val) validator.validateField(self + { transport_socket_match_criteria: val }, 'transport_socket_match_criteria', type + '.withTransportSocketMatchCriteria'),
    withUnhealthyEdgeInterval:: function(val) validator.validateField(self + { unhealthy_edge_interval: val }, 'unhealthy_edge_interval', type + '.withUnhealthyEdgeInterval'),
    withUnhealthyInterval:: function(val) validator.validateField(self + { unhealthy_interval: val }, 'unhealthy_interval', type + '.withUnhealthyInterval'),
    withUnhealthyThreshold:: function(val) validator.validateField(self + { unhealthy_threshold: val }, 'unhealthy_threshold', type + '.withUnhealthyThreshold'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
