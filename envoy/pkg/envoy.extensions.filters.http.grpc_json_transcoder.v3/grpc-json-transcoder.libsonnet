// Message type: envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder';
local generator = import '../generator.libsonnet';
local fields = {
  auto_mapping: {
    type: 'bool',
    allowedNames: [
      'auto_mapping',
      'autoMapping',
    ],
  },
  case_insensitive_enum_parsing: {
    type: 'bool',
    allowedNames: [
      'case_insensitive_enum_parsing',
      'caseInsensitiveEnumParsing',
    ],
  },
  convert_grpc_status: {
    type: 'bool',
    allowedNames: [
      'convert_grpc_status',
      'convertGrpcStatus',
    ],
  },
  ignore_unknown_query_parameters: {
    type: 'bool',
    allowedNames: [
      'ignore_unknown_query_parameters',
      'ignoreUnknownQueryParameters',
    ],
  },
  ignored_query_parameters: {
    type: 'string',
    allowedNames: [
      'ignored_query_parameters',
      'ignoredQueryParameters',
    ],
    containerType: 'list',
  },
  match_incoming_request_route: {
    type: 'bool',
    allowedNames: [
      'match_incoming_request_route',
      'matchIncomingRequestRoute',
    ],
  },
  match_unregistered_custom_verb: {
    type: 'bool',
    allowedNames: [
      'match_unregistered_custom_verb',
      'matchUnregisteredCustomVerb',
    ],
  },
  max_request_body_size: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'max_request_body_size',
      'maxRequestBodySize',
    ],
    constraints: {
      Uint32: {
        gt: 0,
      },
    },
  },
  max_response_body_size: {
    type: 'google.protobuf.UInt32Value',
    allowedNames: [
      'max_response_body_size',
      'maxResponseBodySize',
    ],
    constraints: {
      Uint32: {
        gt: 0,
      },
    },
  },
  print_options: {
    type: 'envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.PrintOptions',
    allowedNames: [
      'print_options',
      'printOptions',
    ],
  },
  proto_descriptor: {
    type: 'string',
    allowedNames: [
      'proto_descriptor',
      'protoDescriptor',
    ],
  },
  proto_descriptor_bin: {
    type: 'bytes',
    allowedNames: [
      'proto_descriptor_bin',
      'protoDescriptorBin',
    ],
  },
  query_param_unescape_plus: {
    type: 'bool',
    allowedNames: [
      'query_param_unescape_plus',
      'queryParamUnescapePlus',
    ],
  },
  request_validation_options: {
    type: 'envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions',
    allowedNames: [
      'request_validation_options',
      'requestValidationOptions',
    ],
  },
  services: {
    type: 'string',
    allowedNames: [
      'services',
    ],
    containerType: 'list',
  },
  url_unescape_spec: {
    type: 'envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.UrlUnescapeSpec',
    allowedNames: [
      'url_unescape_spec',
      'urlUnescapeSpec',
    ],
    constraints: {
      Enum: {
        defined_only: true,
      },
    },
  },
};
local oneOfs = [
  {
    fields: [
      'proto_descriptor',
      'proto_descriptor_bin',
    ],
    required: true,
    group: 'descriptor_set',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    UrlUnescapeSpec:: (import 'grpc-json-transcoder-url-unescape-spec.libsonnet').definition,
    PrintOptions:: (import 'grpc-json-transcoder-print-options.libsonnet').definition,
    RequestValidationOptions:: (import 'grpc-json-transcoder-request-validation-options.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAutoMapping:: function(val) validator.validateField(self + { auto_mapping: val }, 'auto_mapping', type + '.withAutoMapping'),
    withCaseInsensitiveEnumParsing:: function(val) validator.validateField(self + { case_insensitive_enum_parsing: val }, 'case_insensitive_enum_parsing', type + '.withCaseInsensitiveEnumParsing'),
    withConvertGrpcStatus:: function(val) validator.validateField(self + { convert_grpc_status: val }, 'convert_grpc_status', type + '.withConvertGrpcStatus'),
    withIgnoreUnknownQueryParameters:: function(val) validator.validateField(self + { ignore_unknown_query_parameters: val }, 'ignore_unknown_query_parameters', type + '.withIgnoreUnknownQueryParameters'),
    withIgnoredQueryParameters:: function(val) validator.validateField(self + { ignored_query_parameters: val }, 'ignored_query_parameters', type + '.withIgnoredQueryParameters'),
    withMatchIncomingRequestRoute:: function(val) validator.validateField(self + { match_incoming_request_route: val }, 'match_incoming_request_route', type + '.withMatchIncomingRequestRoute'),
    withMatchUnregisteredCustomVerb:: function(val) validator.validateField(self + { match_unregistered_custom_verb: val }, 'match_unregistered_custom_verb', type + '.withMatchUnregisteredCustomVerb'),
    withMaxRequestBodySize:: function(val) validator.validateField(self + { max_request_body_size: val }, 'max_request_body_size', type + '.withMaxRequestBodySize'),
    withMaxResponseBodySize:: function(val) validator.validateField(self + { max_response_body_size: val }, 'max_response_body_size', type + '.withMaxResponseBodySize'),
    withPrintOptions:: function(val) validator.validateField(self + { print_options: val }, 'print_options', type + '.withPrintOptions'),
    withProtoDescriptor:: function(val) validator.validateField(self + { proto_descriptor: val }, 'proto_descriptor', type + '.withProtoDescriptor'),
    withProtoDescriptorBin:: function(val) validator.validateField(self + { proto_descriptor_bin: val }, 'proto_descriptor_bin', type + '.withProtoDescriptorBin'),
    withQueryParamUnescapePlus:: function(val) validator.validateField(self + { query_param_unescape_plus: val }, 'query_param_unescape_plus', type + '.withQueryParamUnescapePlus'),
    withRequestValidationOptions:: function(val) validator.validateField(self + { request_validation_options: val }, 'request_validation_options', type + '.withRequestValidationOptions'),
    withServices:: function(val) validator.validateField(self + { services: val }, 'services', type + '.withServices'),
    withUrlUnescapeSpec:: function(val) validator.validateField(self + { url_unescape_spec: val }, 'url_unescape_spec', type + '.withUrlUnescapeSpec'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
