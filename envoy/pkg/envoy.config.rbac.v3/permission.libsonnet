// Message type: envoy.config.rbac.v3.Permission
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.rbac.v3.Permission';
local generator = import '../generator.libsonnet';
local fields = {
  and_rules: {
    type: 'envoy.config.rbac.v3.Permission.Set',
    allowedNames: [
      'and_rules',
      'andRules',
    ],
  },
  any: {
    type: 'bool',
    allowedNames: [
      'any',
    ],
    constraints: {
      Bool: {
        const: true,
      },
    },
  },
  destination_ip: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'destination_ip',
      'destinationIp',
    ],
  },
  destination_port: {
    type: 'uint32',
    allowedNames: [
      'destination_port',
      'destinationPort',
    ],
    constraints: {
      Uint32: {
        lte: 65535,
      },
    },
  },
  destination_port_range: {
    type: 'envoy.type.v3.Int32Range',
    allowedNames: [
      'destination_port_range',
      'destinationPortRange',
    ],
  },
  header: {
    type: 'envoy.config.route.v3.HeaderMatcher',
    allowedNames: [
      'header',
    ],
  },
  matcher: {
    type: 'envoy.config.core.v3.TypedExtensionConfig',
    allowedNames: [
      'matcher',
    ],
  },
  metadata: {
    type: 'envoy.type.matcher.v3.MetadataMatcher',
    allowedNames: [
      'metadata',
    ],
  },
  not_rule: {
    type: 'envoy.config.rbac.v3.Permission',
    allowedNames: [
      'not_rule',
      'notRule',
    ],
  },
  or_rules: {
    type: 'envoy.config.rbac.v3.Permission.Set',
    allowedNames: [
      'or_rules',
      'orRules',
    ],
  },
  requested_server_name: {
    type: 'envoy.type.matcher.v3.StringMatcher',
    allowedNames: [
      'requested_server_name',
      'requestedServerName',
    ],
  },
  url_path: {
    type: 'envoy.type.matcher.v3.PathMatcher',
    allowedNames: [
      'url_path',
      'urlPath',
    ],
  },
};
local oneOfs = [
  {
    fields: [
      'and_rules',
      'or_rules',
      'any',
      'header',
      'url_path',
      'destination_ip',
      'destination_port',
      'destination_port_range',
      'metadata',
      'not_rule',
      'requested_server_name',
      'matcher',
    ],
    required: true,
    group: 'rule',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    Set:: (import 'permission-set.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAndRules:: function(val) validator.validateField(self + { and_rules: val }, 'and_rules', type + '.withAndRules'),
    withAny:: function(val) validator.validateField(self + { any: val }, 'any', type + '.withAny'),
    withDestinationIp:: function(val) validator.validateField(self + { destination_ip: val }, 'destination_ip', type + '.withDestinationIp'),
    withDestinationPort:: function(val) validator.validateField(self + { destination_port: val }, 'destination_port', type + '.withDestinationPort'),
    withDestinationPortRange:: function(val) validator.validateField(self + { destination_port_range: val }, 'destination_port_range', type + '.withDestinationPortRange'),
    withHeader:: function(val) validator.validateField(self + { header: val }, 'header', type + '.withHeader'),
    withMatcher:: function(val) validator.validateField(self + { matcher: val }, 'matcher', type + '.withMatcher'),
    withMetadata:: function(val) validator.validateField(self + { metadata: val }, 'metadata', type + '.withMetadata'),
    withNotRule:: function(val) validator.validateField(self + { not_rule: val }, 'not_rule', type + '.withNotRule'),
    withOrRules:: function(val) validator.validateField(self + { or_rules: val }, 'or_rules', type + '.withOrRules'),
    withRequestedServerName:: function(val) validator.validateField(self + { requested_server_name: val }, 'requested_server_name', type + '.withRequestedServerName'),
    withUrlPath:: function(val) validator.validateField(self + { url_path: val }, 'url_path', type + '.withUrlPath'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
