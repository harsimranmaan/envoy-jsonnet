// Message type: envoy.config.rbac.v3.Principal
// Definition generated by protoc-gen-jsonnet. DO NOT EDIT.

local type = 'envoy.config.rbac.v3.Principal';
local generator = import '../generator.libsonnet';
local fields = {
  and_ids: {
    type: 'envoy.config.rbac.v3.Principal.Set',
    allowedNames: [
      'and_ids',
      'andIds',
    ],
  },
  any: {
    type: 'bool',
    allowedNames: [
      'any',
    ],
    constraints: {
      Bool: {
        const: true,
      },
    },
  },
  authenticated: {
    type: 'envoy.config.rbac.v3.Principal.Authenticated',
    allowedNames: [
      'authenticated',
    ],
  },
  direct_remote_ip: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'direct_remote_ip',
      'directRemoteIp',
    ],
  },
  filter_state: {
    type: 'envoy.type.matcher.v3.FilterStateMatcher',
    allowedNames: [
      'filter_state',
      'filterState',
    ],
  },
  header: {
    type: 'envoy.config.route.v3.HeaderMatcher',
    allowedNames: [
      'header',
    ],
  },
  metadata: {
    type: 'envoy.type.matcher.v3.MetadataMatcher',
    allowedNames: [
      'metadata',
    ],
  },
  not_id: {
    type: 'envoy.config.rbac.v3.Principal',
    allowedNames: [
      'not_id',
      'notId',
    ],
  },
  or_ids: {
    type: 'envoy.config.rbac.v3.Principal.Set',
    allowedNames: [
      'or_ids',
      'orIds',
    ],
  },
  remote_ip: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'remote_ip',
      'remoteIp',
    ],
  },
  source_ip: {
    type: 'envoy.config.core.v3.CidrRange',
    allowedNames: [
      'source_ip',
      'sourceIp',
    ],
  },
  url_path: {
    type: 'envoy.type.matcher.v3.PathMatcher',
    allowedNames: [
      'url_path',
      'urlPath',
    ],
  },
};
local oneOfs = [
  {
    fields: [
      'and_ids',
      'or_ids',
      'any',
      'authenticated',
      'source_ip',
      'direct_remote_ip',
      'remote_ip',
      'header',
      'url_path',
      'metadata',
      'filter_state',
      'not_id',
    ],
    required: true,
    group: 'identifier',
  },
];
local validator = generator(type, fields, oneOfs);

{
  definition: {
    Set:: (import 'principal-set.libsonnet').definition,
    Authenticated:: (import 'principal-authenticated.libsonnet').definition,

    // methods
    _new:: function(partialObject={}) (
      local obj = if std.type(partialObject) != 'object' then error 'expected object for _new invocation of %s' % type else partialObject;
      validator.validatePartial(obj + self)
    ),
    _validate:: function() validator.validateAll(self),
    _normalize:: function(kind='') validator.normalizeAll(self, kind),
    withAndIds:: function(val) validator.validateField(self + { and_ids: val }, 'and_ids', type + '.withAndIds'),
    withAny:: function(val) validator.validateField(self + { any: val }, 'any', type + '.withAny'),
    withAuthenticated:: function(val) validator.validateField(self + { authenticated: val }, 'authenticated', type + '.withAuthenticated'),
    withDirectRemoteIp:: function(val) validator.validateField(self + { direct_remote_ip: val }, 'direct_remote_ip', type + '.withDirectRemoteIp'),
    withFilterState:: function(val) validator.validateField(self + { filter_state: val }, 'filter_state', type + '.withFilterState'),
    withHeader:: function(val) validator.validateField(self + { header: val }, 'header', type + '.withHeader'),
    withMetadata:: function(val) validator.validateField(self + { metadata: val }, 'metadata', type + '.withMetadata'),
    withNotId:: function(val) validator.validateField(self + { not_id: val }, 'not_id', type + '.withNotId'),
    withOrIds:: function(val) validator.validateField(self + { or_ids: val }, 'or_ids', type + '.withOrIds'),
    withRemoteIp:: function(val) validator.validateField(self + { remote_ip: val }, 'remote_ip', type + '.withRemoteIp'),
    withSourceIp:: function(val) validator.validateField(self + { source_ip: val }, 'source_ip', type + '.withSourceIp'),
    withUrlPath:: function(val) validator.validateField(self + { url_path: val }, 'url_path', type + '.withUrlPath'),
  },
  validator:: validator.validateAll,
  normalizer: validator.normalizeAll,
}
